## 第一章：Java语言概述

### 1.软件开发介绍：

- ##### 软件开发：

  - 软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有**系统软件**和**应用软件**之分。

- ##### 人机交互方式：

  - **图形化界面**（Graphical User Interface GUl)这种方式简单直观，使用者易于接受，容易上手操作。
  - **命令行方式**（Command Line Interface CLl)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。

- ##### 常用的DOS命令

  - dir : 列出当前目录下的文件以及文件夹
  - md :创建目录
  - rd : 删除目录
  - cd : 进入指定目录
  - cd.. : 退回到上一级目录
  - cd\ : 退回到根目录
  - del : 删除文件
  - exit : 退出dos命令行

- ##### 常用的快捷键

  - ← →：移动光标
  - ↑ ↓：调阅历史操作命令
  - Delete和Backspace:删除字符

### 2.计算机编程语言介绍：

- ##### 什么是计算机语言

  - 语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，就要学习英语。

  - 计算机语言：人与计算机交流的方式。

    - ###### 如果人要与计算机交流，那么就要学习计算机语言。

    - ###### 计算机语言有很多种。如：C，C++，Java，PHP，Kotlin，Python，Scala等。

- 第一代语言：

  - 机器语言。指令以二进制代码形式存在

- 第二代语言：

  - 汇编语言。使用助记符表示一条机器指令

- 第三代语言：

  - C、Pascal、Fortran面向过程的语言
  - C++面向过程/面向对象
  - Java跨平台的纯面向对象的语言
  - .NET跨语言的平台
  - Python、Scala...

### 3.Java语言概述

-  是SUN（Stanford University Network,斯坦福大学网络公司）1995年推出的一门高级编程语言。

- 是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。applet内嵌在HTML代码中。

-  随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。

- ##### Java简史：

  - 1991年Green项目，开发语言最初命名为Oak（橡树）

  - 1994年，开发组意识到Oak非常适合于互联网

  - 1996年，发布JDK1.0，约8.3万个网页应用Java技术来制作

  - 1997年，发布JDK1.1，JavaOne会议召开，创当时全球同类会议规模之最

  - 1998年，发布JDK1.2，同年发布企业平台J2EE

  - 1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生

  - ###### 2004年，发布里程碑式版本：JDK1.5，为突出此版本的重要性，更名为JDK5.0

  - 2005年,J2SE->JavaSE,J2EE->JavaEE,J2ME->JavaME

  - 2009年，Oracle公司收购SUN，交易价格74亿美元

  - 2011年，发布JDK7.0

  - 2014年，发布JDK8.0，是继JDK5.0以来变化最大的版本

  - ###### 2017年，发布JDK9.0，最大限度实现模块化

  - 2018年3月，发布JDK10.0，版本号也称为18.3

  - 2018年9月，发布JDK11.0，版本号也称为18.9

- ##### Java技术体系平台

  | Java SE(Java Standard Edition)标准版                         |
  | ------------------------------------------------------------ |
  | 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API,此版本以前称为J2SE |
  | **Java EE(Java Enterprise Edition)企业版**                   |
  | 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如：Servlet、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE |
  | **Java ME(Java Micro Edition)小型版**                        |
  | 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java APl有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME |
  | **Java Card**                                                |
  | 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 |

- ##### Java在各领域的应用

  - 从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面：
    - **企业级应用**：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。
    - **Android平台应用**：Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。
    - **大数据平台开发**：各类框架有Hadoop，spark，storm，flink等，就这类技术生态圈来讲，还有各种中间件如flume，kafka,sqoop等等，这些框架以及工具大多数是用Java编写而成，但提供诸如Java，scala，Python，R等各种语言API供编程。
    - 移动领域应用：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。

- ##### 主要特性：

  - 易学
  - 强制面向对象的
  - 分布式的
  - 健壮的
  - 安全的
  - 体系结构中立的
  - 解释型的
  - 性能略高
  - 原生支持多线程

### 4.Java程序运行机制及运行过程

- ##### 特点一：**面向对象**

  - 两个基本概念：类、对象
  - 三大特性：封装、继承、多态

- ##### 特点二：**健壮性**

  - 吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制

- ##### 特点三：**跨平台性**

  - 跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Writeonce，Run Anywhere”
  - 原理：只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机（JVM JavaVirtual Machine)即可。由JVM来负责Java程序在该系统中的运行。

- ##### 两种核心机制

  - Java虚拟机
  - 垃圾收集机制

- ##### 核心机制一Java虚拟机

  - JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。
  - 对于不同的平台，有不同的虚拟机。
  - 只有某平台提供了对应的java虚拟机，java程序才可在此平台运行
  - Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”

- #####  核心机制一垃圾回收

  - 不再使用的内存空间应回收——垃圾回收。

    - 在C/C++等语言中，由程序员负责回收无用内存。
    - Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。

  - 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。

  - ###### Java程序还会出现内存泄漏和内存溢出问题吗?Yes!

### 5.相关问题

- ##### 超纲题目：GC是什么? 为什么要有GC

  - 答：GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

- ##### 超纲题目：垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收

  - 答：对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。
  - 当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

## 第二章：Java基本语法

### 1.关键字和保留字

- ##### 关键字（keyword)的定义和特点

  - 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）
  - 特点：关键字中所有字母都为小写
  - 官方地址：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html

  | 用于定义数据类型的关键字                                     |
  | ------------------------------------------------------------ |
  | class，interface，enum，byte，short，int，long，float，double，char，boolean，void |
  | **用于定义流程控制的关键字**                                 |
  | if，else，switch，case，default，while，do，for，break，continue，return |
  | **用于定义访问权限修饰符的关键字**                           |
  | private，protected，public                                   |
  | **用于定义类，函数，变量修饰符的关键字**                     |
  | abstract，final，static，synchronized                        |
  | **用于定义类与类之间关系的关键字**                           |
  | extends，implements                                          |
  | **用于定义建立实例及引用实例，判断实例的关键字**             |
  | new，this，super，instanceof                                 |
  | **用于异常处理的关键字**                                     |
  | try，catch，finally，throw，throws                           |
  | **用于包的关键字**                                           |
  | package，import                                              |
  | **其他修饰符关键字**                                         |
  | native，strictfp，transient，volatile，assert                |
  | **用于定义数据类型值的字面值**                               |
  | true，false，null                                            |

- ##### Java保留字：

  - 现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto、const

### 2.标识符

- ##### 标识符：

  - Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符
  - 技巧：凡是自己可以起名字的地方都叫标识符。

- ##### 定义合法标识符规则：

  - 由26个英文字母大小写，0-9，_或$组成
  - **数字不可以开头。**
  - 不可以使用关键字和保留字，但能包含关键字和保留字。
  - Java中严格区分大小写，长度无限制。
  - 标识符不能包含空格。

- ##### Java中的名称命名规范：

  - 包名：多单词组成时所有字母都**小写**：xxxyyyzzz
  - 类名、接口名：多单词组成时，所有单词的**首字母大写**：XxxYyyZzz
  - 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz
  - 常量名：所有字母都**大写**。多单词时每个单词用下划线连接：XXX_YYY_zzz

### 3.变量

- ##### 变量的概念：

  - 内存中的一个存储区域
  - 该区域的数据可以在同一类型范围内不断变化
  - 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值

- ##### 变量的作用：

  - 用于在内存中保存数据

- ##### 使用变量注意：

  - Java中每个变量必须先声明，后使用
  - 使用变量名来访问这块区域的数据
  - 变量的作用域：其定义所在的一对{}内
  - 变量只有在其作用域内才有效
  - 同一个作用域内，不能定义重名的变量

- ##### 声明变量

  - 语法：<数据类型><变量名称>
  - 例如：int var；

- ##### 变量的赋值

  - 语法：<变量名称>=<值>
  - 例如：var=10；

- ##### 声明和赋值变量

  - 语法：<数据类型><变量名>=<初始化值>
  - 例如：int var=10；

-  对于每一种数据都定义了明确的具体数据类型（**强类型语言**），在内存中分配了不同大小的内存空间。

- ##### 数据类型

  - 基本数据类型
    - 数值型
      - 整数类型(byte,short，int,long)
      - 浮点类型(（float,double)
    - 字符类型（char）
    - 布尔类型（boolean）
  - 引用数据类型：
    - 类（class)
    - 接口(interface)
    - 数组([])

- ##### 变量的分类-按声明的位置的不同

  - 在方法体外，类体内声明的变量称为**成员变量**。
  - 在方法体内部声明的变量称为**局部变量**。
  - 所有变量：
    - 成员变量：
      - 实例变量（不以static修饰）
      - 类变量(以static修饰)
    - 局部变量：
      - 形参（方法、构造器中定义的变量）
      - 方法局部变量 (在方法内定义)
      - 代码块局部变量（在代码块内定义)
  - 注意：二者在初始化值方面的异同：
    - 同：都有生命周期
    - 异：**局部变量除形参外，需显式初始化。**

- #####  整数类型：byte、short、int、long

  -  Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。

  - java的整型常量默认为int型，声明long型常量须后加‘l'或'L'

  - java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long类型

    | 类型  | 占用存储空间 |        表数范围        |
    | :---: | :----------: | :--------------------: |
    | byte  | 1字节=8bit位 |        -128~127        |
    | short |    2字节     |      -2^15~2^15-1      |
    |  int  |    4字节     | -2^31~2^31-1（约21亿） |
    | long  |    8字节     |      -2^63~2^63-1      |

- #####  浮点类型：float、double

  - 与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。

  - 浮点型常量有两种表示形式：

    - 十进制数形式：如：5.12 512.0f 512（必须有小数点）
    - 科学计数法形式：如：5.12e2 512E2 100E-2

  - float:单精度，尾数可以精确到**7**位有效数字。很多情况下，精度很难满足需求。

  - double:双精度，精度是float的两倍。通常采用此类型。

  - ######  Java的浮点型常量默认为double型，声明float型常量，须后加‘或‘F'。

    |     类型     | 占用存储空间 |       表数范围       |
    | :----------: | :----------: | :------------------: |
    | 单精度float  |    4字节     |  -3.403E38~3.403E38  |
    | 双进度double |    8字节     | -1.798E308~1.798E308 |

- ##### 字符类型：char

  - char型数据用来表示通常意义上“字符”（2字节）

  - Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。

  - 字符型变量的三种表现形式：

    - 字符常量是用单引号（‘’）括起来的单个字符。例如：char c1='a'；char c2='中'；char c3='9'；
    - Java中还允许使用转义字符‘’来将其后的字符转变为特殊字符型常量。
      - 例如：char c3=''\n’；//'\n'表示换行符
    - 直接使用Unicode值来表示字符型常量：\uXXXX’。其中，XXXX代表一个十六进制整数。如：u000a表示n。

  - char类型是可以进行运算的。因为它都对应有Unicode码。

    | 转义字符 |  说明  |
    | :------: | :----: |
    |    \b    | 退格符 |
    |    \n    | 换行符 |
    |    \r    | 回车符 |
    |    \t    | 制表符 |
    |    \"    | 双引号 |
    |    \'    | 单引号 |
    |    \\    | 反斜杠 |

- ##### 了解：ASCll码

  - 在计算机内部，所有数据都使用二进制表示。每一个二进制位（bit)有0和1两种状态，因此8个二进制位就可以组合出256种状态，这被称为一个字节（byte)。一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。
  -  ASCll码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASClI码。ASCll码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。
  - 缺点：
    - 不能表示所有字符。
    - 相同的编码表示的字符不一样：比如，130在法语编码中代表了e，在希伯来语编码中却代表了字母Gimel

- #####  了解：Unicode编码

  - 乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。
  - Unicode:一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode没有乱码的问题。
  - Unicode的缺点：Unicode只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别 Unicode和ASCll：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。

- ##### 了解：UTF-8

  - UTF-8是在互联网上使用最广的一种Unicode的实现方式。
  - UTF-8是一种变长的编码方式。它可以使用1-6个字节表示一个符号，根据不同的符号而变化字节长度。
  - UTF-8的编码规则：
    - 对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCll码）。
    - 对于多字节的UTF-8编码，如果编码包含n个字节，那么第一个字节的前n位为1，第一个字节的第n+1位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为“10"，其余6位用来对字符进行编码。

- ##### 布尔类型：boolean

  - boolean 类型用来判断逻辑条件，一般用于程序流程控制：

    - if条件控制语句；
    - while循环控制语句；
    - do-while循环控制语句；
    - for循环控制语句；

  - ###### boolean类型数据只允许取值true和false，无null。

    - 不可以使用0或非0的整数替代false和true，这点和C语言不同。
    - Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：**true用1表示，false用0表示。**——《java虚拟机规范8版》

- #####  基本数据类型转换

  - 自动类型转换：容量小的类型自动转换为容量大的数据类型。
  - 数据类型按容量大小排序为：char byte short -> int -> long -> float -> double
  - 有多种类型的数据混合运算时，**系统首先自动将所有数据转换成容量最大的那种数据类型**，然后再进行计算。
  - **byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型**。
  - **boolean类型不能与其它数据类型运算。**
  - **当把任何基本数据类型的值和字符串（String)进行连接运算时（+），基本数据类型的值将自动转化为字符串（String)类型。**

- ##### 字符串类型：String

  - String不是基本数据类型，属于引用数据类型

  - 使用方式与基本数据类型一致。例如：String str=“abcd"；

  - 一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。

  - 例如：str=str+"xyz”；int n=100；str=str+n;

    ```java
      String str1=4；//判断对错：no 
      String str2=3.5f+"";//判断str2对错：yes 
      System.out.println(str2);//输出：”3.5” 
      System.out.println(3+4+"Hello!");//输出：7Hello!
      System.out.println("Hello!"+3+4);//输出：Hellol34
      System.out.println('a'+1+"Hello!");//输出:98Hello!
      System.out.println("Hello"+'a'+1);//输出：Helloa1
    ```

- ##### 强制类型转换

  - 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：（），但可能造成**精度降低或溢出**，格外要注意。

  -  通常，字符串不能直接转换为基本类型，但通过基本类型对应的**包装类**则可以实现把字符串转换成基本类型。

  - 如：String a="43"；int i=Integer.parselnt(a)；

  - boolean类型不可以转换为其它的数据类型。

    ```java
    short s=5; s=s-2; //判断：no 
    byte b=3; b=b+4; //判断：no 
    b=(byte)(b+4); //判断：yes 
    char c='a'; int i=5; floatd=.314F; double result=c+i+d;//判断：yes 
    byte b=5; short s=3； short t=s+b;//判断：no
    ```

- ##### 变量之进制

  - 所有数字在计算机底层都以**二进制**形式存在。
  - 对于整数，有四种表示方式：
    - 二进制（binary)：0，1，满2进1.以Ob或0B开头。
    - 十进制（decimal)：0-9，满10进1。
    - 八进制（octal)：0-7，满8进1.以数字0开头表示。
    - 十六进制（hex)：0-9及A-F，满16进1.以Ox或0X开头表示。此处的A-F不区分大小写。 如：0×21AF+1=0X21B0
  -  Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位
  - 二进制的整数有如下三种形式：
    - 原码：直接将一个数值换成二进制数。最高位是符号位
    - 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。
    - 负数的补码：其反码加1。
  - 计算机以二进制补码的形式保存所有的整数。
    - 正数的原码、反码、补码都相同
    - 负数的补码是其反码+1

### 4.运算符

- 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。

  - 算术运算符
  - 赋值运算符
  - 比较运算符（关系运算符）
  - 逻辑运算符
  - 位运算符
  - 三元运算符

- ##### 算数运算符

  |   运算符   |                        运算                        |            范例            |          结果          |
  | :--------: | :------------------------------------------------: | :------------------------: | :--------------------: |
  |     +      |                        正号                        |             +3             |           3            |
  |     -      |                        负号                        |           b=4;-b           |           -4           |
  |     +      |                         加                         |            5+5             |           10           |
  |     -      |                         减                         |            6-4             |           2            |
  |     *      |                         乘                         |            3*4             |           12           |
  |     /      |                         除                         |            5/5             |           1            |
  |     %      |                     取模(取余)                     |            7%5             |           2            |
  | ++<br />++ | 自增(前)：先运算后取值<br />自增(后)：先取值后运算 | a=2;b=++a;<br />a=2;b=a++; | a=3;b=3<br />a=3;b=2;  |
  | --<br />-- | 自减(前)：先运算后取值<br />自减(后)：先取值后运算 | a=2;b=--a;<br />a=2;b=a--; | a=1;b=1;<br />a=1;b=2; |
  |     +      |                     字符串连接                     |         "He"+"llo"         |        "Hello"         |

- #####  算术运算符的注意问题

  - 如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。
  - 对于除号“/”，它的整数除和小数除是有区别的：
    - 整数之间做除法时，只保留整数部分而舍弃小数部分。
    - 例如：int x=3510；x=x/1000*1000；x的结果是3000
    - “+”除字符串相加功能外，还能把非字符串转换成字符串.
    - 例如：System.out.printin(“5+5="+5+5)；//打印结果是5+5=55

- ##### 赋值运算符

  - 符号：=
    - 当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。
    - 支持连续赋值。
  - 扩展赋值运算符：+=，-=，*=，/=，%=

- ##### 比较运算符

  |   运算符   |        运算        |           范例            | 结果  |
  | :--------: | :----------------: | :-----------------------: | :---: |
  |     ==     |       相等于       |           4==3            | false |
  |     !=     |       不等于       |           4!=3            | true  |
  |     <      |        小于        |            4<3            | false |
  |     >      |        大于        |            4>3            | true  |
  |     <=     |      小于等于      |           4<=3            | false |
  |     >=     |      大于等于      |           4>=3            | true  |
  | instanceof | 检查是否是类的对象 | "Hello" instanceof String | true  |

  - 比较运算符的结果都是boolean型，也就是要么是true，要么是false。
  - 比较运算符“==”不能误写成“=”。

- ##### 逻辑运算符

  - &—逻辑与 |一逻辑或 ！一逻辑非 &&-短路与 ||一短路或 ^—逻辑异或

    |   a   |   b   |  a&b  | a&&b  | a\|b  | a\|\|b |  !a   |  a^b  |
    | :---: | :---: | :---: | :---: | :---: | :----: | :---: | :---: |
    | true  | true  | true  | true  | true  |  true  | false | false |
    | true  | false | false | false | true  |  true  | false | true  |
    | false | true  | false | false | true  |  true  | true  | true  |
    | false | false | false | false | false | false  | true  | false |

  -  逻辑运算符用于连接布尔型表达式，在Java中不可以写成3<x<6，应该写成x>3&x<6。

  - “&”和“&&”的区别：

    - 单&时，左边无论真假，右边都进行运算；
    - 双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。
    - “|”和“I|"的区别同理，|| 表示：当左边为真，右边不参与运算。

  - 异或（^）与或（|）的不同之处是：

    - 当左右都为true时，结果为false。
    - 理解：异或，追求的是“异”！

  ```java
  class Test{
      public static void main(String [] args){
          boolean x = true;
          boolean y = false;
          short z = 42;
          if((z++==42) && (y=true)) z++;
          if((x=false) || (++z == 45)) z++;
          System.out.println("z="+z);
      }
  }
  //结果为：z=46
  ```

- ##### 位运算符

  | 运算符 |    运算    |          范例           |
  | :----: | :--------: | :---------------------: |
  |   <<   |    左移    | 3<<2 = 12 -->3\*2\*2=12 |
  |   >>   |    右移    |    3>>1=1 --> 3/2=1     |
  |  >>>   | 无符号右移 |  3>>>1 = 1 --> 3/2 =1   |
  |   &    |   与运算   |        6 & 3 = 2        |
  |   \|   |   或运算   |       6 \| 3 = 7        |
  |   ^    |  异或运算  |        6 ^ 3 = 5        |
  |   ~    |  取反运算  |         ~6 = -7         |

  - 位运算是直接对整数的二进制进行的运算

  | 运算符 |                             细节                             |
  | :----: | :----------------------------------------------------------: |
  |   <<   |            空位补0，被移除的高位丢弃，空缺位补0。            |
  |   >>   | 被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。 |
  |  >>>   |      被移位二进制最高位无论是0或者是1，空缺位都用0补。       |
  |   &    |        二进制位进行&运算，只有1&1时结果是1，否则是0；        |
  |   \|   |     二进制位进行 \| 运算，只有0 \| 0时结果是0，否则是1；     |
  |   ^    | 相同二进制位进行^运算，结果是0；1^1=0，0^0=0<br />不相同二进制位^运算结果是1。1^0=1，0^1=1 |
  |   ~    | 正数取反，各二进制码按补码各位取反<br />负数取反，各二进制码按补码各位取反 |

- ##### 三元运算符

  -  格式：（条件表达式）？表达式1：表达式2；
    - 条件表达式为true,运算后的结果是表达式1；
    - 条件表达式为false，运算后的结果是表达式2；
  - 表达式1和表达式2为同种类型>
  - 三元运算符与if-else的联系与区别：
    - 1）三元运算符可简化if-else语句
    - 2）三元运算符要求必须返回一个结果。
    - 3）if后的代码块可有多个语句

- ##### 运算符的优先级

  - 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如下表，上一行运算符总优先于下一行。

  -  只有单目运算符、三元运算符、赋值运算符是从右向左运算的。

    |      |     .  ()  {}  ;  ,     |
    | :--: | :---------------------: |
    | R->L | ++  --  ~  !(data type) |
    | L->R |         *  /  %         |
    | L->R |          +  -           |
    | L->R |       <<  >> >>>        |
    | L->R | <  > <=  >=  instanceof |
    | L->R |         ==  !=          |
    | L->R |            &            |
    | L->R |            ^            |
    | L->R |           \|            |
    | L->R |           &&            |
    | L->R |          \|\|           |
    | R->L |          ?  :           |
    | R->L |      =  *=  /=  %=      |
    |      |    +=  -=  <<=  >>=     |
    |      |    >>>=  &=  ^=  \|=    |

### 5.程序流程控制

-  流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。

- 其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：

  - 顺序结构
  - 分支结构
  - 循环结构

- ##### 顺序结构

  - 程序从上到下逐行地执行，中间没有任何判断和跳转。

  - Java中定义成员变量时采用合法的前向引用。

    ```java
    public class Test{
        int num1 = 12;
        int num2 = num1 +2;
    }
    //错误形式：
    public class Test{
        int num2 = num1 +2;
        int num1 = 12;
    }
    ```

- ##### 分支结构

  - 根据条件，选择性地执行某段代码。

  - 有if..else和switch-case两种分支语句。

  - if-else结构

    ```java
    //if语句三种格式：
    //格式1:
    if(条件表达式){
        //执行代码块;
    }
    //格式2:
    if(条件表达式){
    	//执行代码块1;
    }else{
        //执行代码块2;
    }
    //格式3:
    if(条件表达式1){
       //执行代码块1;
    }else if(条件表达2){
    	//执行代码块2;
    }
    // ...
    else{
        //执行代码块n
    }
    ```

  - 分支结构：if-else使用说明

    - 条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量
    - 语句块只有一条执行语句时，一对{}可以省略，但建议保留
    - if-else语句结构，根据需要可以嵌套使用
    - 当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略
    - 当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓
    - 当多个条件是“包含”关系时，“小上大下/子上父下”

  - switch-case结构

    ```java
    switch(表达式){
        case 常量1:
            语句1;
            break;
        case 常量2:
            语句2;
            break;
        ... ...
        case 常量N:
            语句N;
            break;
        default:
            语句;
            break;
    }
    ```

  - ##### switch语句有关规则

    - switch(表达式）中表达式的值必须是下述几种类型之一：**byte，short，char,int,枚举（jdk 5.0），String(jdk 7.0)；**
    - case子句中的值必须是**常量**，不能是变量名或不确定的表达式值；
    - 同一个switch语句，所有case子句中的常量值互不相同；
    - break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到switch结尾
    - default子句**是可任选的**。同时，**位置也是灵活的**。当没有匹配的case时，执行default

  - ##### switch和if语句的对比

    - if和switch语句很像，具体什么场景下，应用哪个语句呢？
      - 如果判断的具体数值不多，而且符合byte、short、char、int、String、枚举等几种类型。虽然两个语句都可以使用，建议使用swtich语句。**因为效率稍高**。
      - 其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。也就是说，**使用switch-case的，都可以改写为if-else。反之不成立。**

- ##### 循环结构

  - 根据循环条件，重复性的执行某段代码。

  - 有while、do...while、for三种循环语句。

  - 注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。

  - for 循环

    - 语法格式

      - for (①初始化部分;②循环条件部分;④迭代部分) {

        ​	③循环体部分;

      ​        }

    - 执行过程:

      -  ①-②-③-④-②-③-④-②-③-④....②

    - 说明:

      - ②循环条件部分为boolean类型表达式，当值为false时，退出循环
      - ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔
      - ④可以有多个变量更新，用逗号分隔

  - ##### while循环

    - 语法格式

      - ①初始化部分

        while(②循环条件部分）{

        ​         ③循环体部分；

        ​         ④迭代部分；

         }

    - 执行过程：①-②-③-④-②-③-④-②-③-④..②

    - 说明：

      - 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。
      - for循环和while循环可以相互转换

  - ##### do-while循环

    - 语法格式

      - ①初始化部分；

        do{

        ​     ③循环体部分

        ​     ④迭代部分

        }while(②循环条件部分）；

    - 执行过程：①-③-④-②-④-②-④..②

    - 说明：

      - **do-while循环至少执行一次循环体。**

  - ##### 嵌套循环结构

    -  将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do...while均可以作为外层循环或内层循环。
    - 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。
    -  设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。

  - ##### 特殊关键字的使用：break，continue
  
    - break语句
  
      - break语句用于终止某个语句块的执行
  
        - {      ……
              break；
  
          ​    ……
  
           }
  
      - break语句出现在多层嵌套的语句块中时，可以**通过标签指明要终止的是哪一层语句块**
  
      - label1: {……
  
        - label2：{……
          - label3：{……
            - break label2；
            - ……
            - }
          - }
  
      - }
  
    - continue语句：
  
      - continue只能使用在循环结构中
      - continue语句用于跳过其所在循环语句块的**一次**执行，继续下一次循环
      - continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环
  
  - ##### return的使用
  
    - return:并非专门用于结束循环的，它的功能是结束一个方法。 当一个方法执行到一个return语句时，这个方法将被结束。
    - 与break和continue不同的是，return直接结束整个方法，不管这个return**处于多少层**循环之内
  
  - ##### 特殊流程控制语句说明
  
    - break只能用于**switch语句和循环语句**中。
    - continue只能用于**循环语句**中。
    -  二者功能类似，但continue是**终止本次**循环，break是**终止本层**循环。
    -  break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。
    -  标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。
    - 很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。

### 6.相关问题

- ##### 编写代码实现两个变量值交换，int m = 3, n =5;

  ```java
  //答案一：
  int temp = m;
  m = n;
  n = temp;
  //答案二：
  m = m + n;
  n = m - n;
  m = m - n;
  //答案三：
  m = m ^ n;
  n = m ^ n;
  m = m ^ n;
  
  ```

- ##### 如何求一个0~255范围内的整数的十六进制值，例如60的十六进制表示形式3C

  ```java
  //方式一：自动实现
  String str1 = Integer.toBinaryString(60);
  String str2 = Integer.toHexString(60);
  
  //方式二：手动实现
  int i1 = 60;
  //取出后4位的二进制，并转换成16进制
  int i2 = i1&15;
  String j = (i2 > 9)? (char)(i2-10 + 'A')+"" : i2+"";
  //取出前4位的二进制，并转换成16进制
  int temp = i1 >>> 4;
  i2 = temp & 15;
  String k = (i2 > 9)? (char)(i2-10 + 'A')+"" : i2+"";
  System.out.println(k+""+j);
  
  ```

- ##### 比较 +  与  +=

  ```java
  //short s1 = 1; s1 = s1 + 1;有什么错? 
  //short s1 = 1; s1 += 1;有什么错?
  
  //答：short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，需要强制转换类型）
  //short s1 = 1; s1 += 1;（可以正确编译）
  
  ```

## 第三章：数组

### 1.数组的概述

- 数组（Array），是多个**相同类型数据**按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。
- 数组的常见概念
  - 数组名
  - 下标（或索引）
  - 元素
  - 数组的长度
- 数组本身是**引用数据类型**，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。
-  创建数组对象会在内存中开辟一整块**连续的空间**，而数组名中引用的是这块连续空间的首地址。
- 数组的长度一旦确定，就**不能修改**。
- 我们可以直接通过下标（或索引）的方式调用指定位置的元素，速度很快。
- 数组的分类：
  - 按照维度：一维数组、二维数组、三维数组、…
  - 按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组（即**对象数组**）

### 2.一维数组的使用

- ##### 一维数组的声明方式：

  - type var[]或type[] var；
  - 例如：
    - int a[]；
    - int[] a1；
    - double b[]；
    - String [] c；//引用类型变量数组
  - Java语言中**声明数组时不能指定其长度**（数组中元素的数），例如：int a[5]；//非法

- ##### 一维数组的使用：初始化

  - 动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行

    ```java
    int [] arr = new int[3];
    arr[0] = 3;
    arr[1] = 9;
    arr[2] = 8;
    String names[];
    names=new String[3];
    names[0]="钱学森";
    names[1]="邓稼先";
    names[2]="袁隆平";
    ```

  - 静态初始化：在定义数组的同时就为数组元素分配空间并赋值

    ```java
    int arr[] = new int[] {3,9,8};
    int [] arr1 = {3,9,8};//类型推断
    String names[] = {"李四光","茅以升","华罗庚"};
    ```

- ##### 一维数组的使用：数据元素的引用

  - 定义并用运算符**new**为之分配空间后，才可以引用数组中的每个元素；
  - 数组元素的引用方式：数组名[数组元素下标]
    - 数组元素下标可以是整型常量或**整型表达式**。如a[3]，bi]，c[6*i]；
    - 数组元素下标从0开始；长度为n的数组合法下标取值范围：0->n-1；如int all=new int[3]；可引用的数组元素为a[0]、a[1]、a[2]
  - 每个数组都有一个属性**length**指明它的长度，例如：a.length指明数组a的长度（元素个数）
    - 数组一旦初始化，其长度是不可变的

- ##### 一维数组的使用：数组元素的默认初始值

  - 数组是引用类型，它的元素相当于**类的成员变量**，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。

  - 例如：

    ```java
    public class Test{
        public static void main(String argvl){
            int all=new int[5];
            System.out.printin(a[3]);//a[3]的默认值为0
        }
    }
    ```

  - 对于基本数据类型而言，默认初始化值各有不同

  - 对于引用数据类型而言，默认初始化值为null（注意与0不同！）

    | 数据元素类型 |      元素默认初始值      |
    | :----------: | :----------------------: |
    |     byte     |            0             |
    |    short     |            0             |
    |     int      |            0             |
    |     long     |            0L            |
    |    float     |           0.0F           |
    |    double    |           0.0            |
    |     char     | 0或写:'\u0000'(表现为空) |
    |   boolean    |          false           |
    |   引用类型   |           null           |

- ##### 一维数组的使用

  - 创建基本数据类型数组

    - Java中使用关键字new来创建数组

    ```java
    public class Test{ 
        public static void main(String args[]){ 
            int[]s; 
            s=new int[10];
            //基本数据类型数组在显示赋值之前
            //java会自动给他们赋默认值。
            for(int i=0；i<10；i++){ 
                s[i]=2*i+1;
                System.out.printin(s[i]);
            }
        }
    }
    ```

### 3.多维数组的使用

-  Java 语言里提供了支持多维数组的语法。

- 如果说可以把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格。

-  对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。**其实，从数组底层的运行机制来看，其实没有多维数组。**

  |                  二维数组[][]:数组中的数组                   |
  | :----------------------------------------------------------: |
  |      格式1（动态初始化）：int[][] arr = new int[3][2];       |
  | 定义了名称为arr的二维数组<br />二维数组中有3个一维数组<br />每一个一维数组中有2个元素<br />一维数组的名称分别为arr[0],arr[1],arr[2]<br />给第一个一维数组1脚标位赋值为78写法是：arr[0]  [1] =78 |
  |     格式2（动态初始化）：int [] [] arr = new int [3] [];     |
  | 二维数组中有3个一维数组。<br/>    每个一维数组都是默认初始化值null（注意：区别于格式1）<br />可以对这个三个一维数组分别进行初始化<br />arr[0]=new int[3];arr[1]=new int[1];arr[2]=new int[2];<br />注：<br />int[] []arr=new int[][3];//非法 |
  | 格式3（静态初始化）：int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}； |
  | 定义一个名称为arr的二维数组，二维数组中有三个一维数组<br />每一个一维数组中具体元素也都已初始化<br />第一个一维数组arr[0]={3,8，2}；<br />第二个一维数组arr[1]={2,7}；<br />第三个一维数组arr[2]={9,0,1,6}；<br />第三个一维数组的长度表示方式：arr[2].length； |
  | **注意特殊写法情况：int[]x，y[]；x是一维数组，y是二维数组。**<br/>    Java中多维数组**不**必都是规则矩阵形式 |

### 4.数组中涉及的常见算法

- 数组元素的赋值（杨辉三角、回形数等）

- 求数值型数组中元素的最大值、最小值、平均数、总和等

- 数组的复制、反转、查找（线性查找、二分法查找）

- 数组元素的排序算法

- ##### 排序算法

  - 排序：假设含有n个记录的序列为（R1，R2，……Rn}，其相应的关键字序列为{K1，K2，.…,Kn}。将这些记录重新排序为{Ri1，Ri2…,Rin}，使得相应的关键字值满足条Kil<=Ki2<=..<=Kin,这样的一种操作称为排序。

    - **通常来说，排序的目的是快速查找。**

  - 衡量排序算法的优劣：

    - 1.时间复杂度：分析关键字的比较次数和记录的移动次数
    - 2.空间复杂度：分析排序算法中需要多少辅助内存
    - 3.稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。

  -   排序分为两类：

    - （1）内排序：指待排序列完全存放在内存中所进行的排序。内排序大致可分为五类：插入排序、交换排序、选择排序、归并排序和分配排序。
    - 2）外排序：指排序过程中还需访问外存储器的排序。
          为了以后讨论方便，我们直接将排序码写成一个一维数组的形式，并且在没有声明的情形下，所有排序都按排序码的值递增排列。

  - 十大内部排序算法

    - 选择排序
      - 直接选择排序、堆排序
    - 交换排序
      - 冒泡排序、快速排序
    - 插入排序
      - 直接插入排序、折半插入排序、Shell排序
    - 归并排序
    - 桶式排序
    - 基数排序

  - 算法的5大特征

    |          输入（lnput)          |     有0个或多个输入数据，这些输入必须有清楚的描述和定义      |
    | :----------------------------: | :----------------------------------------------------------: |
    |         输出（Output)          |         至少有1个或多个输出结果，不可以没有输出结果          |
    |  有穷性（有限性，Finiteness）  | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤<br />可以在可接受的时间内完成 |
    | 确定性（明确性，Definiteness)  |         算法中的每一步都有确定的含义，不会出现二义性         |
    | 可行性（有效性，Effectiveness) |  算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案  |

  - 说明：满足确定性的算法也称为：确定性算法。现在人们也关注更广泛的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程（procedure）。

  - ##### 冒泡排序

    -  介绍：冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
    - 排序思想：
      - 1.比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
      - 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
      - 3.针对所有的元素重复以上的步骤，除了最后一个。
      - 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。

  - ##### 快速排序

    -  介绍：快速排序通常明显比同为O（nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。
    - 快速排序（Quick Sort)由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n)）。
    -  排序思想：
      - 1.从数列中挑出一个元素，称为“基准”（pivot），
      - 2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边)。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition)操作。
      - 3.递归地（recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。
      - 4.递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration)中，它至少会把一个元素摆到它最后的位置去。

  - #####  各种内部排序方法性能比较

    - 1.从平均时间而言：**快速排序**最佳。但在最坏情况下时间性能不如堆排序和归并排序。
    - 2.从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。
    - 3.从稳定性看：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、Shel排序和堆排序是不稳定排序
    - 4.从待排序的记录数n的大小看，**n较小时，宜采用简单排序；而n较大时宜采用改进排序**。

  -   排序算法的选择

    - （1）若n较小（如n<=50），可采用**直接插入或直接选择排序**。
          当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。
    - （2）若文件初始状态**基本有序**（指正序），则应选用直接插入、冒泡或随机的快速排序为宜；
    - （3）若n较大，则应采用时间复杂度为o（nlgn)的排序方法：快速排序、堆排序或归并排序。

### 5.Arrays工具类的使用

- java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。

|  1   | boolean equals(int [] a, int [] b) |         判断两个数组是否相等         |
| :--: | :--------------------------------: | :----------------------------------: |
|  2   |      String toString(int[] a)      |             输出数组信息             |
|  3   |    void fill(int[] a, int val)     |        将指定值填充到数组之中        |
|  4   |         void sort(int[] a)         |            对数组进行排序            |
|  5   | int binarySearch(int[] a, int key) | 对排序后的数组进行二分法检索指定的值 |

### 6.数组使用中的常见异常

|     数组脚标越界异常（ArrrayIndexOutOfBoundsException）      |
| :----------------------------------------------------------: |
| int [] arr = new int[2];<br />System.out.println(arr[2]);<br />System.out.println(arr[-1]);<br />访问到了数组中的不存在的脚标时发生 |
|              空指针异常（NullPointerException）              |
| int [] arr = null;<br />System.out.println(arr[0]);<br />arr引用没有指向实体，却在操作实体中的元素时。 |

### 7.面试题

- ##### 创建一个长度为6的int型数组，要求取值为1-30，同时元素值各不相同

  ```java
  class ArrayExer {
  	public static void main(String[] args) {
  		//方式一：
  //		int[] arr = new int[6];
  //		for (int i = 0; i < arr.length; i++) {// [0,1) [0,30) [1,31)
  //			arr[i] = (int) (Math.random() * 30) + 1;
  //
  //			boolean flag = false;
  //			while (true) {
  //				for (int j = 0; j < i; j++) {
  //					if (arr[i] == arr[j]) {
  //						flag = true;
  //						break;
  //					}
  //				}
  //				if (flag) {
  //					arr[i] = (int) (Math.random() * 30) + 1;
  //					flag = false;
  //					continue;
  //				}
  //				break;
  //			}
  //		}
  //
  //		for (int i = 0; i < arr.length; i++) {
  //			System.out.println(arr[i]);
  //		}
  		//方式二：
  		int[] arr = new int[6];
  		for (int i = 0; i < arr.length; i++) {// [0,1) [0,30) [1,31)
  			arr[i] = (int) (Math.random() * 30) + 1;
  			
  				for (int j = 0; j < i; j++) {
  					if (arr[i] == arr[j]) {
  						i--;
  						break;
  					}
  				}
  			}
  
  		for (int i = 0; i < arr.length; i++) {
  			System.out.println(arr[i]);
  		}
  	}
  }
  ```

## 第四章：面向对象

### 1.面向过程与面向对象

-  面向过程（POP）与面向对象（OOP）
  - 二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。
  - 面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
  - 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。
- 面向对象的三大特征
  - 封装（Encapsulation)
  - 继承（Inheritance)
  - 多态（Polymorphism)
- 面向对象的思想概述
  -  程序员从面向过程的**执行者**转化成了面向对象的**指挥者**
  - 面向对象分析方法分析问题的思路和步骤：
    - 根据问题需要，选择问题所针对的**现实世界中的实体**。
    - 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了**概念世界中的类**。
    - 把抽象的实体用计算机语言进行描述，**形成计算机世界中类的定义**。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。
    - 将**类实例化成计算机世界中的对象**。对象是计算机世界中解决问题的最终工具。

### 2.类和对象

-   类（Class)和对象（Object）是面向对象的核心概念。

  - 类是对一类事物的描述，是**抽象的**、概念上的定义
  - 对象是**实际存在**的该类事物的每个个体，因而也称为**实例**（instance)。

-  **“万事万物皆对象”**

- 可以理解为：**类=抽象概念的人**；**对象=实实在在的某个人**

- 面向对象程序设计的重点是**类的设计**

- 类的设计，**其实就是类的成员的设计**

- ##### java类以及类的成员

  -  现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多个不同功能的类构成的。
  - 现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、…那么，Java中用类class来描述事物也是如此。
  - 常见的类的成员有：
    - 属性：对应类中的成员变量
    - 行为：对应类中的成员方法
  - **Field=属性=成员变量，Method=(成员）方法=函数**

- ##### 类的语法格式

  ```java
  //修饰符 class 类名{
  	//属性声明;
  	//方法声明;
  //}
  //说明：修饰符public:类可以被任意访问
  // 类的正文要用{}括起来
  public class Person{
      private int age; // 声明私有变量age
      public void showAge(int i){ //声明方法showAge()
          age = i;
      }
  }
  ```

- ##### 创建Java自定义类步骤：

  - 1.定义类（考虑修饰符、类名）
  - 2.编写类的属性（考虑修饰符、属性类型、属性名、初始化值）
  - 3.编写类的方法（考虑修饰符、返回值类型、方法名、形参等）

### 3.对象的创建和使用

- java类的实例化，即创建类的对象

- 创建对象语法：类名对象名=new类名（）；

- 使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）

  ```java
  //说明：如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。
  public class Animal{ 
      public int legs; 
      public void eat(){ 
          System.out.printin("Eating.");
      } 
      public viod move(){ 
          System.out.println("Move.");
      }
  }
  public class Zoo{ 
      public static void main(String args[]){ 
          //创建对象 
          Animal xb=new Animal(); 
          xb.legs=4;//访问属性 
          System.out.println(xb.legs); 
          xb.eat();//访问方法 
          xb.move（);//访问方法
      }
  }
  ```

- 类的访问机制：

  - **在一个类中的访问机制**：类中的方法可以直接访问类中的成员变量。
        （例外：**static方法访问非static，编译不通过。**）
  - **在不同类中的访问机制**：先创建要访问类的对象，再用对象访问类中定义的成员。

- ##### 内存解析

  - 堆（Heap)，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：**所有的对象实例以及数组都要在堆上分配**。
  - 通常所说的栈（Stack)，是指虚拟机栈。虚拟机栈用于**存储局部变量**等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型它不等同于对象本身，是对象在堆内存的首地址）。**方法执行完，自动释放**。
  - 方法区（Method Area)，用于存储已被虚拟机加载的**类信息、常量、静态变量**、**即时编译器编译后的代码**等数据。

- ##### 匿名对象

  - 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。
    -  如：new Person().shout()；
  - 使用情况
    - 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。
    - 我们经常将匿名对象作为实参传递给一个方法调用。

### 4.属性

-  语法格式：

  - 修饰符  数据类型   属性名=初始化值；

  - 说明1：修饰符

    - 常用的权限修饰符有：private、缺省、protected、public
    - 其他修饰符：static、final（暂不考虑）

  - 说明2：数据类型

    - 任何基本数据类型（如int、Boolean)或任何引用数据类型。

  - 说明3：属性名

    - 属于标识符，符合命名规则和规范即可。

    ```java
    public class Person{ 
        private int age;//声明private变量age
        public String name="Lila";//声明public变量name
    }
    ```

- ##### 变量的分类：成员变量和局部变量

  -  在方法体外，类体内声明的变量称为成员变量。
  - 在方法体内部声明的变量称为局部变量。
  - 所有变量
    - 成员变量
      - 实例变量（不以static修饰）
      - 类变量（以static修饰）
    - 局部变量
      - 形参（方法，构造器中定义的变量）
      - 方法的局部变量（在方法内定义）
      - 代码块的局部变量（在代码块内定义）
  - 注意：二者在初始化值方面的异同：
    - 同：都有生命周期
    - 异：局部变量除形参外，均需显式初始化。

- 成员变量（属性）和局部变量的区别

  |              |             成员变量             |                局部变量                |
  | :----------: | :------------------------------: | :------------------------------------: |
  |  声明的位置  |          直接声明在类中          |  方法形参或内部，代码块内，构造器内等  |
  |    修饰符    | private，public，static，final等 |   不能用权限修饰符，可以用final修饰    |
  |   初始化值   |           有默认初始值           | 没有默认初始值，必须显示赋值，方可使用 |
  | 内存加载位置 |         堆空间或静态域内         |                 栈空间                 |

- ##### 对象属性的默认初始化赋值

  - 当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变量类型都是引用类型。

  | 成员变量类型 |            初始值            |
  | :----------: | :--------------------------: |
  |     byte     |              0               |
  |    short     |              0               |
  |     int      |              0               |
  |     long     |              0L              |
  |    float     |             0.0F             |
  |    double    |             0.0              |
  |     char     | 0或写为：‘\u000’（表现为空） |
  |   boolean    |            false             |
  |   引用类型   |             null             |

### 5.方法

-  什么是方法（method、函数）：

  - 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。

  - 将功能封装为方法的目的是，可以实现代码重用，简化代码

  - Java里的方法不能独立存在，所有的方法必须定义在类里。

    ```java
    public class Person{ 
        private int age; 
        public int getAge(){//声明方法getAge() 
            return age; 
        }
        public void setAge(inti){//声明方法setAge 
            age=i;//将参数i的值赋给类的成员变量age
        }
    }
    ```

- #####  方法的声明格式：

  - 修饰符 返回值类型  方法名（参数类型 形参1，参数类型 形参2, .…){
    - 方法体程序代码
    - return 返回值；
    - }
  - 其中：
    - 修饰符：public，缺省，private，protected等
    - 返回值类型：
      - 没有返回值：void。
      - 有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用
      - 方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“，”隔开
      - 返回值：方法在执行完毕后返还给调用它的程序的数据。

- ##### 方法的分类：

  |        |         无返回值          |             有返回值              |
  | :----: | :-----------------------: | :-------------------------------: |
  | 无形参 |     void 方法名（）{}     |      返回值的类型 方法名(){}      |
  | 有形参 | void 方法名（形参列表）{} | 返回值的类型 方法名（形参列表）{} |

- 方法的调用

  - 方法通过方法名被调用，且只有被调用才会执行。

- 注意：

  - 方法被调用一次，就会执行一次
  - 没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。
  - 定义方法时，方法的结果应该返回给调用者，交由调用者处理。
  - 方法中只能调用方法或属性，不可以在方法内部定义方法。

- ##### 方法的重载：

  - 重载的概念：

    - 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

  - 重载的特点：

    - 与**返回值类型无关**，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别。

  -  重载示例：

    ```java
    //返回两个整数的和
    int add(int x,int y){return x+y;}
    //返回三个整数的和
    int add(int x,int y,int z){return x+y+z}
    //返回两个小数的和
    double add(double x,double y){return x+y;}
    ```

- ##### 可变个数的形参：

  -  JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。

    ```java
     //JDK5.0以前：采用数组形参来定义方法，传入多个同一类型变量
    public static void test(int a,String[] books);
    //JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
    public static void test(int a,String...books)；
    ```

  - 说明：
    - 1.声明格式：**方法名（参数的类型名.…参数名）**
    - 2.可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个
    - 3.可变个数形参的方法与同名的方法之间，彼此构成重载
    - 4.可变参数方法的使用与方法参数部分使用数组是一致的
    - 5.方法的参数部分有可变形参，需要放在形参声明的最后
    - 6.在一个方法的形参位置，最多只能声明一个可变个数形参

- ##### 方法参数的值的传递机制：

  -  方法，必须由其所在类或对象调用才有意义。若方法含有参数：
    - 形参：方法声明时的参数
    - 实参：方法调用时实际传给形参的参数值
  - Java的实参值如何传入方法呢?
        Java里方法的参数传递方式只有一种：**值传递**。即将实际**参数值的副本（复制品）传入方法内**，而参数本身不受影响。
    - 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参
    - 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参

- ##### 递归方法：

  - **递归方法：一个方法体内调用它自身**。
  - 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
  - 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

  ```java
   //计算1-100之间所有自然数的和
  public int sum(int num){
      if(num==1){
          return 1;
      }else{
          return num+sum(num-1);
      }
  }
  ```

### 6.封装和隐藏

- 为什么需要封装？封装的作用和含义？

  - 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？
  - 我要开车，…

- 我们程序设计追求“高内聚，低耦合”。

  - 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
  - 低耦合：仅对外暴露少量的方法用于使用。

- 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，**把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。**

- ##### 信息的封装和隐藏

  - Java中通过将数据声明为私有的（private），再提供公共的（public)方法：getXxx(）和setXxx（）实现对该属性的操作，以实现下述目的：
    - 隐藏一个类中不需要对外提供的实现细节；
    - 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；
    - 便于修改，增强代码的可维护性；

- ##### 四种访问权限修饰符

  - Java权限修饰符public、protected、（缺省）、private置于类的成员定义前，用来限定对象对该类成员的访问权限。

  - 对于class的权限修饰只可以用public和default（缺省）。

    - public类可以在任意地方被访问。
    - default类只可以被同一个包内部的类访问。

    |  修饰符   | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
    | :-------: | :----: | :------: | :----------: | :--------: |
    |  private  |  Yes   |          |              |            |
    |  (缺省)   |  Yes   |   Yes    |              |            |
    | protected |  Yes   |   Yes    |     Yes      |            |
    |  public   |  Yes   |   Yes    |     Yes      |    Yes     |

### 7.构造器（或构造方法）

- 构造器的特征

  - 它具有与类相同的名称
  - 它不声明返回值类型。（与声明为void不同）
  - 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值

- 构造器的作用：**创建对象；给对象进行初始化**

  - 如：Order o=new Order()；Person p=new Person("Peter",15)；
  - 如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。

- 语法格式： 

  - 修饰符 类名（参数列表）{ 
    - 初始化语句； 
    - }

- 举例：

  ```java
  public class Animal{ 
      private int 1egs; 
      //构造器 
      public Animal(){
          legs=4;
      } 
      public void setLegs(int i){ 
          legs=i;
      } 
      public int getLegs(){ 
          return legs;
      } 
  }
  ```

-  创建Animal类的实例：Animal a=new Animal()； 

- 调用构造器，将legs初始化为4。

- 根据参数不同，构造器可以分为如下两类：

  - 隐式无参构造器（系统默认提供）
  - 显式定义一个或多个构造器（无参、有参）

- 注意：

  - Java语言中，每个类都至少有一个构造器
  - 默认构造器的修饰符与所属类的修饰符一致
  - 一旦显式定义了构造器，则系统**不再**提供默认构造器
  - 一个类可以创建多个**重载**的构造器
  - **父类的构造器不可被子类继承**

- ##### 构造器重载

  - 构造器一般用来创建对象的同时初始化对象。
  - 构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。

- ##### 属性赋值过程

  -   截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位置，并指明赋值的先后顺序。
  - 赋值的位置：
    - ①默认初始化
    - ②显式初始化
    - ③构造器中初始化
    - ④通过“对象.属性“或“对象.方法”的方式赋值
    - **赋值的先后顺序：①-②-③-④**

- ##### JavaBean

  - JavaBean是一种Java语言写成的可重用组件。
  - 所谓javaBean,是指符合如下标准的Java类：
    - 类是公共的
    - 有一个无参的公共的构造器
    - 有属性，且有对应的get、set方法
  - 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

### 8.this的使用

-   在Java中，this关键字比较难理解，它的作用和其词义很接近。
  - 它在方法内部使用，即这个方法所属对象的引用；
  - 它在构造器内部使用，表示该构造器正在初始化的对象。
-  this 可以调用类的属性、方法和构造器
- 什么时候使用this关键字呢？
  - 当在方法内**需要用到调用该方法的对象时**，就用this。
  -  具体的：我们可以用this来区分属性和局部变量。
  - 比如：this.name=name；
- 注意：
  - 可以在类的构造器中使用"this（形参列表）”的方式，调用本类中重载的其他的构造器！
  - 明确：构造器中不能通过“this（形参列表）”的方式调用自身构造器
  - 如果一个类中声明了n个构造器，则最多有n-1个构造器中使用了"this(形参列表）"
  - "this(形参列表）“必须声明在类的构造器的首行！
  - 在类的一个构造器中，最多只能声明一个"this（形参列表）"

### 9.package，import的使用

- package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。（若缺省该语句，则指定为无名包）。它的格式为：package 顶层包名.子包名；

- 包对应于文件系统的目录，package语句中，用“.”来指明包（目录）的层次；

- 包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx

- 包的作用：

  - 包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式
  - 包可以包含类和子包，划分项目层次，便于管理
  - 解决类命名冲突的问题
  - 控制访问权限

- ##### JDK中主要的包介绍

  - 1.java.lang----包含一些Java语言的核心类，如String、Math、Integer、System和Thread,提供常用功能
  - 2.java.net----包含执行与网络相关的操作的类和接口。
  - 3.java.io----包含能提供多种输入/输出功能的类。
  - 4.java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数
  - 5.java.text----包含了一些java格式化相关的类
  - 6.java.sql----包含了java进行JDBC数据库编程的相关类/接口
  - 7.java.awt---包含了构成抽象窗口工具集（abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）。B/S C/S

- ##### 关键字-import

  -  为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类（.*）。import语句告诉编译器到哪里去寻找类。
  - 语法格式：import 包名.类名；
  - 注意：
    - 1.在源文件中使用import显式的导入指定包下的类或接口
    - 2.声明在包的声明和类的声明之间。
    - 3.如果需要导入多个类或接口，那么就并列显式多个import语句即可
    - 4.举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。
    - 5.如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。
    - 6.如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。
    - 7.如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。
    -  8.import static组合的使用：调用指定类或接口下的静态的属性或方法

### 10.继承性

- 为什么要有继承？

  - 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

- 此处的多个类称为子类（派生类），单独的这个类称为父类（基类或超类）。可以理解为：“子类is a父类”

- 类继承语法规则：class Subclass extends SuperClass{}

- 作用：

  - 继承的出现减少了代码冗余，提高了代码的复用性。
  - 继承的出现，更有利于功能的扩展。
  - 继承的出现让类与类之间产生了关系，提供了多态的前提。

- 注意：不要仅为了获取其他类中某个功能而去继承

-  子类继承了父类，就**继承了父类的方法和属性**。

- 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。

-  在Java中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“**扩展**”。

- ##### 关于继承的规则：

  - **子类不能直接访问父类中私有的（private）的成员变量和方法。**

- Java只支持**单继承和多层继承**，不允许多重继承

  - 一个子类只能有一个父类
  - 一个父类可以派生出多个子类
    - class SubDemo extends Demo{}//ok
    - class SubDemo extends Demo1,Demo2...//error

### 11.方法的重写

- 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的**重置、覆盖**。在程序执行时，子类的方法将覆盖父类的方法。
- 要求：
  - 1.子类重写的方法必须和父类被重写的方法具有**相同的方法名称、参数列表**
  - 2.子类重写的方法的**返回值类型不能大于父类被重写**的方法的返回值类型
  - 3.子类重写的方法**使用的访问权限不能小于父类被重写**的方法的访问权限
    - 子类不能重写父类中声明为private权限的方法4.子类方法抛出的异常不能大于父类被重写方法的异常
- 注意：子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static的（不是重写）。因为**static方法是属于类的，子类无法覆盖父类的方法。**

### 12.关键字：super

- 在Java类中使用super来调用父类中的指定操作：

  - super可用于访问父类中定义的属性
  - super可用于调用父类中定义的成员方法
  - super可用于在子类构造器中调用父类的构造器

- 注意：

  - 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员
  - super的追溯不仅限于直接父类
  - super和this的用法相像，this代表本类对象的引用，**super代表父类的内存空间的标识**

- 子类中所有的构造器**默认**都会访问父类中**空参数**的构造器

- 当父类中没有空参数的构造器时，子类的构造器必须通过this（参数列表）或者super(参数列表）语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行

- 如果子类构造器中**既未显式调用父类或本类的构造器**，且父类中又没有无参的构造器，则**编译出错**

- this和super的区别

  | No.  |   区别点   |                             this                             |                     super                      |
  | :--: | :--------: | :----------------------------------------------------------: | :--------------------------------------------: |
  |  1   |  访问属性  | 访问本类中的属性，如果本类没<br />有此属性则从父类中继续寻找 |              直接访问父类中的属性              |
  |  2   |  调用方法  | 访问本类中的方法，如果本类没<br />有此方法则从父类中继续寻找 |              直接访问父类中的方法              |
  |  3   | 调用构造器 |          调用本类构造器，必须放在构造<br />器的首行          | 调用父类构造器，必须<br />放在子类构造器的首行 |

### 13.子类实例化过程

```java
class Creature{ 
    public Creature(){ 
        System.out.println("Creature无参数的构造器");
   }}
class Animal extends Creature{ 
    public Animal(String name){ 
        System.out.println("Animal带一个参数的构造器，该动物的name为"+name);
     } 
    public Animal(String name,int age){ 
        this(name); 
        System.out.println("Animal带两个参数的构造器，其age为"+age); 
    }} 
public class Wolf extends Animal{ 
    public Wolf(){ 
        super("灰太狼",3); 
        System.out.println("Wolf无参数的构造器"); 
    } 
   public static void main(String[] args){
       new Wolf();
   }}
//输出的结果:
//Creature无参数的构造器
//Animal带一个参数的构造器，该动物的name为灰太狼
//Animal带两个参数的构造器，其age为3
//Wolf无参数的构造器
```

### 14.多态性

- 多态性，是面向对象中最重要的概念，在Java中的体现：

- 对象的多态性：父类的引用指向子类的对象

  - **可以直接应用在抽象类和接口上**

- Java引用变量有两个类型：**编译时类型和运行时类型**。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：**编译时，看左边；运行时，看右边**。

  - 若编译时类型和运行时类型不一致，就出现了对象的多态性（Polymorphism)
  - 多态情况下，
    - “看左边”：看的是父类的引用（父类中不具备子类特有的方法）
    - “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）

- 对象的多态一在Java中，子类的对象可以替代父类的对象使用

  - 一个变量只能有一种确定的数据类型
  - 一个引用类型变量可能指向（引用）多种不同类型的对象
  - Person p=new Student()；
  - Object o=new Person()；//Object类型的变量o，指向Person类型的对象
  - o=new Student()；//Object类型的变量o，指向Student类型的对象

- **子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。**

- 一个引用类型变量**如果声明为父类的类型**，但**实际引用的是子类对象**，那么该变量就**不能再访问子类中添加的属性和方法**

  - Student m=new Student()；
  - m.school=“pku”；//合法，Student类有school成员变量
  - Person e=new Student()；
  - e.school=“pku”；//非法，Person类没有school成员变量
  - **属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。**

- 正常的方法调用

  - Person e=new Person()；
  - e.getlnfo()；
  - Studente=new Student();
  - e.getlnfo(）；

- 虚拟方法调用（多态情况下）

  - 子类中定义了与**父类同名同参数的方法**，在多态情况下，**将此时父类的方法称为虚拟方法**，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
  - Person e=new Student()；
  - e.getlnfo（）；//调用Student类的getinfo（）方法

- 编译时类型和运行时类型

  - 编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getlnfo(）方法。——**动态绑定**

- ##### 方法的重载与重写

  - 重载，是指允许存在多个同名方法，而这些方法的**参数不同**。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，**即子类可以重载父类的同名不同参数的方法**。
  - 所以：对于重载而言，在方法调用之前，**编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”**；
  - 而对于多态，只有等到**方法调用的那一刻**，解释运行器才会确定所要调用的具体方法，这称为“**晚绑定”或“动态绑定”。**
  - 引用一句BruceEckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”

- ##### 多态小结

  -   多态作用：
    - 提高了代码的通用性，常称作接口重用
  - 前提：
    - 需要存在继承或者实现关系
    - 有方法的重写
  - 成员方法：
    - 编译时：要查看引用变量所声明的类中是否有所调用的方法。
    - 运行时：调用实际new的对象所属的类中的重写方法。
  - 成员变量：不具备多态性，只看引用变量所声明的类。
  
- ##### instanceof操作符

  - xinstanceof A：检验x是否为类A的对象，返回值为boolean型。
    - 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。
    - 如果x属于类A的子类B，xinstanceof A值也为true。

- ##### 对象类型转换

  - 基本数据类型的Casting:
    - **自动类型转换**：小的数据类型可以自动转换成大的数据类型
      - 如long g=20；double d=12.0f
    - **强制类型转换**：可以把大的数据类型强制转换（casting)成小的数据类型
      - 如float f=(float)12.0；int a=(int)1200L
  - 对Java对象的强制类型转换称为造型
    - 从子类到父类的类型转换可以自动进行
    - 从父类到子类的类型转换必须通过造型（**强制类型转换**）实现
    - **无继承关系的引用类型间的转换是非法的**
    - 在造型前可以使用instanceof操作符测试一个对象的类型

- #####  子类继承父类

  - 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
  - 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，**这个实例变量依然不可能覆盖父类中定义的实例变量**

### 15.Object类的使用

- Object类是所有Java类的根父类

- 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类

- Object类中的主要结构

  |  NO  |             方法名称              | 类型 |      描述      |
  | :--: | :-------------------------------: | :--: | :------------: |
  |  1   |          public Object()          | 构造 |     构造器     |
  |  2   | public boolean equals(Object obj) | 普通 |    对象比较    |
  |  3   |       public int hashCode()       | 普通 |   取得Hash码   |
  |  4   |      public String toString       | 普通 | 对象打印时调用 |

- ##### ==操作符与equals方法

  - ==:
    - 基本类型比较值：只要两个变量的值相等，即为true。
      - int a=5；if(a==6){..…}
    - 引用类型比较引用（是否指向同一个对象）：只有指向同一个对象时，==才返回true。 
      - Person p1=new Person()；
      - Person p2=new Person()；
      - if(p1==p2){..…}
    - 用“==”进行比较时，符号两边的数据类型**必须兼容**（可自动转换的基本数据类型除外），否则编译出错
  -  equals():所有类都继承了Object，也就获得了equals（）方法。还可以重写。
    - 只能比较引用类型，其作用与“==”相同，比较是否指向同一个对象。
    - 格式:obj1.equals(obj2)
  - 特例：当用equals（）方法进行比较时，对类File、String、Date及包装类（Wrapper Class)来说，是比较类型及内容而不考虑引用的是否是同一个对象；
    - 原因：在这些类中重写了Object类的equals（）方法。
  - 当自定义使用equals（）时，**可以重写。用于比较两个对象的“内容”是否都相等**

- ##### 重写equals（）方法的原则

  - **对称性**：如果x.equals（y）返回是“true”，那么y.equals（x）也应该返回是“true”。
  - **自反性**：x.equals(x）必须返回是“true”。
  - **传递性**：如果x.equals（y）返回是“true”，而且y.equals(z)返回是“true”，那么z.equals（x）也应该返回是“true”
  - **一致性**：如果x.equals（y）返回是“true”，只要x和y内容一直不变，不管你重复x.equals（y）多少次，返回都是“true”。
  - 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象）永远返回是“false”。

- #####   toString()方法

  - toString)方法在Object类中定义，其返回值是String类型，**返回类名和它的引用地址**。
  - 在进行String与其它类型数据的连接操作时，**自动调用toString(）方法**
    - Date now=new Date()；
    - System.out.println(“now="+now);
    - 相当于System.out.println(“now="+now.toString())；
  - 可以根据需要在用户自定义类型中重写toString（）方法 
    - 如String 类重写了toString（）方法，返回字符串的值。
    - s1=“hello”；
    - System.out.println(s1)；//相当于System.out.printin(s1.toString())；
  - 基本类型数据转换为String类型时，调用了对应**包装类的toString（）方法**
    - int a=10；
    - System.out.println(“a="+a)；

### 16.包装类的使用

- 针对八种基本数据类型定义相应的引用类型—包装类（封装类）

- 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象

  | 基本数据类型 |  包装类   |
  | :----------: | :-------: |
  |     byte     |   Byte    |
  |    short     |   Short   |
  |     int      |  Integer  |
  |     long     |   Long    |
  |    float     |   Float   |
  |    double    |  Double   |
  |   boolean    |  Boolean  |
  |     char     | Character |

- ##### 包装类的使用

  - 基本数据类型包装成包装类的实例--装箱
    - 通过包装类的构造器实现：
      - int i=500；Integer t=new Integer(i)；
      - 还可以通过字符串参数构造包装类对象：
      - Float f=new Float(“4.56")；
      - Longl=new Long(“asdf");//NumberFormatException
  - 获得包装类对象中包装的基本类型变量---拆箱
    - 调用包装类的.xxxValue（）方法：
      - boolean b=bObj.booleanValue()；
  - JDK1.5之后，支持自动装箱，自动拆箱。**但类型必须匹配**。
  - 字符串转换成基本数据类型
    - 通过包装类的构造器实现：
      - int i=new Integer(“12")；
    - 通过包装类的parseXxx（String s)静态方法：
      - Float f=Float.parseFloat(“12.1")；
  - 基本数据类型转换成字符串
    - 调用字符串重载的valueOf(）方法：
      - String fstr=String.valueOf(2.34f)；
    - 更直接的方式：String intStr=5+""
  - 用法举例：
    -  int i=500；
    - Integer t=new Integer(i)；
    - 装箱：包装类使得一个基本数据类型的数据变成了类。
    - 有了类的特点，可以调用类中的方法。
    - String s=t.toString()；//s=“500,t是类，有toString方法
    - String s1=Integer.toString(314)；//s1=“314“将数字转换成字符串。
    - String s2="4.56"；
    - double ds=Double.parseDouble(s2)；//将字符串转换成数字
    - 拆箱：将数字包装类中内容变为基本数据类型。
    - int j = t.intValue()；//j=500,intValue取出包装类中的数据
    - 包装类在实际开发中用的最多的在于字符串变为基本数据类型。
    - String str1="30"；
    - String str2="30.3"；
    - int x=Integer.parselnt(str1);//将字符串变为int型
    - float f=Float.parseFloat(str2)；//将字符串变为int型

### 17.native关键字

-  使用native关键字说明这个方法是原生函数，也就是这个方法是用**C/C++等非Java 语言实现的**，并且被编译成了DLL，由java去调用。
- （1）为什么要用native方法
  - java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。例如：**有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因**，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。
- （2）native声明的方法，对于调用者，可以当做和其他Java方法一样使用
  - 一个native method 方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。
  - native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。
  - 如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（如果需要的话）。

### 18.类与类之间的关系

- ##### 依赖关系
  - 对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。

- ##### 关联关系

  - 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。关联可以有方向，即导航。一般不作说明的时候，导航是双向的，不需要在线上标出箭头。
  - 关联表示类之间的“持久”关系，这种关系一般表示一种重要的业务之间的关系，需要保存的，或者说需要“持久化”的，或者说需要保存到数据库中的。另外，依赖表示类之间的是一种“临时、短暂”关系，这种关系是不需要保存的.

- ##### 聚合关系

  - 聚合（关联关系的一种）：表示has-a的关系。与关联关系一样，聚合关系也是通过实例变量来实现这样关系的。关联关系和聚合关系来语法上是没办法区分的，从**语义上**才能更好的区分两者的区别。
  - 如汽车类与引挚类，轮胎类之间的关系就是整体与个体的关系。
  - 与关联关系一样，聚合关系也是通过实例变量来实现的。空心菱形。
  - 关联和聚集（聚合）的区别：
    - **关联**关系所涉及的两个对象是处在**同一个层次上**的。
    - 比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的。
    - **聚合**关系涉及的两个对象处于**不平等**的层次上，一个代表整体，一个代表部分。
    - 比如电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。

- ##### 组合关系

  -  对象A包含对象B，对象B离开对象A没有实际意义。是一种更强的关联关系。人包含手，手离开人的躯体就失去了它应有的作用。
  -  组合：表示contains-a的关系，是一种强烈的包含关系。**组合类负责被组合类的生命周期**。
  - 也使用属性表达组合关系，是关联关系的一种，是比聚合关系强的关系。

- ##### 继承（泛化，is-a的关系）

  - 类与类的继承关系，类与接口的实现关系。
  - 场景：父与子、动物与人、植物与树

### 19.关键字：static

- 当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，**某些特定的数据在内存空间里只有一份**，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。

- class Circle{ 

  - private double radius； 
  - public Circle(double radius)(this.radius=radius;} 
  - public double findArea(){return Math.PI*radius*radius;} 

- 创建两个Circle对象 

  - Circle c1=new Circle(2.0);//c1.radius=2.0 
  - Circle c2=new Circle(3.0);//c2.radius=3.0 

- Circle类中的变量radius是一个**实例变量**（instance variable），它属于类的 每一个对象，不能被同一个类的不同对象所共享。

- 上例中c1的radius独立于c2的radius，存储在不同的空间。c1中的radius 变化不会影响c2的radius，反之亦然。

- **如果想让一个类的所有实例共享数据，就用类变量！**

- ##### 类属性，类方法的设计思想

  - 类属性作为该类各个对象之间共享的变量。在设计类时，分析哪些属性**不因对象的不同而改变**，将这些属性设置为类属性。相应的方法设置为类方法。
  -  如果方法与调用者无关，则这样的方法通常被声明为类方法，由于**不需要创建对象就可以调用类方法**，从而简化了方法的调用。

- 使用范围：

  - 在Java类中，可用static修饰属性、方法、代码块、内部类

- ##### 被修饰后的成员具备以下特点：

  - 随着类的加载而加载
  - 优先于对象存在
  - 修饰的成员，被所有对象所共享
  - 访问权限允许时，可不创建对象，直接被类调用

- ##### 类方法

  -  没有对象的实例时，可以用类名.方法名（）的形式访问由static修饰的类方法。
  - **在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。**
  - 因为不需要实例就可以访问static方法，因此static方法内部不能有this。（也不能有super?YES!)
  - **static修饰的方法不能被重写**

- ##### 单例设计模式

  -  设计模式是在**大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式**。设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”**套路**”

  - 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法。

  - 如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的**构造器的访问权限设置为private**，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，**只能调用该类的某个静态方法**以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的**该类对象的变量也必须定义成静态的**。

  - 饿汉式

    ```java
    class Singleton{ 
        //1.私有化构造器 
        private Singleton(){}
        //2.内部提供一个当前类的实例 
        //4.此实例也必须静态化
        private static Singleton single=new Singleton(); 
        //3.提供公共的静态的方法，返回当前类的对象 
        public static Singleton getInstance(){ 
            return single;
        }
    }
    ```

  - 懒汉式

    ```java
    class Singleton{ 
        //1.私有化构造器 
        private Singleton(){ }
        //2.内部提供一个当前类的实例 
        //4.此实例也必须静态化 
        private static Singleton single; 
        //3.提供公共的静态的方法，返回当前类的对象 
        public static Singleton getInstance(){ 
            if(single==null){ 
                single=new Singleton();
            }
            return single;
        }
    }
    ```

  - 优点：

    - 由于单例模式只生成一个实例，**减少了系统性能开销**，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

  - 应用场景：

    -  **网站的计数器**，一般也是单例模式实现，否则难以同步。
    - **应用程序的日志应用**，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
    -  **数据库连接池**的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
    - 项目中，**读取配置文件的类**，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。
    - **Application也是单例的典型应用**
    - Windows的**Task Manager(任务管理器）**就是很典型的单例模式
    - Windows的**Recycle Bin(回收站）**也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。

### 20.理解main方法

- 由于Java虚拟机需要调用类的main（）方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main（）方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。
- 又因为main（)方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。

### 21.代码块

-   代码块（或初始化块）的作用：

  - 对Java类或对象进行初始化

- 代码块（或初始化块）的分类：

  - 一个类中代码块**若有修饰符**，则只能被static修饰，称为静态代码块(static block)，没有使用static修饰的，为非静态代码块。

- static代码块通常用于初始化static的属性

  - class Person{
    - public static int total;
    - static{
      - total=100；//为total赋初值
      - }
      - ....//其它属性或方法声明
    - }

- #####  静态代码块：用static修饰的代码块

  - 1.可以有输出语句。
  - 2.可以对类的属性、类的声明进行初始化操作。
  - 3.不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。
  - 4.若有多个静态的代码块，那么按照从上到下的顺序依次执行。
  - 5.**静态代码块的执行要先于非静态代码块**。
  - 6.**静态代码块随着类的加载而加载，且只执行一次。**

- ##### 非静态代码块：没有static修饰的代码块

  - 1.可以有输出语句。
  - 2.可以对类的属性、类的声明进行初始化操作。
  - 3.除了**调用非静态的结构外**，还可以**调用静态的变量或方法。**
  - 4.**若有多个非静态的代码块，那么按照从上到下的顺序依次执行。**
  - 5.**每次创建对象的时候，都会执行一次。且先于构造器执行**。

- 程序中的成员变量赋值的执行顺序

  - 声明成员变量默认初始化
  - 显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）
  - 构造器再对成员进行初始化操作
  - 通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值

### 22.关键字：final

- 在Java中声明类、变量和方法时，可使用关键字final来修饰，表示“**最终的**”。

  - **final标记的类不能被继承**。提高安全性，提高程序的可读性

    - String类、System类、StringBuffer类

  - **final标记的方法不能被子类重写**。

    - 比如：Object类中的getClass()。

  - **final标记的变量（成员变量或局部变量）即称为常量。名称大写，且只能被赋值一次**。

    - final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。
    - final double MY Pl=3.14；

  - ###### static final:全局常量

### 23.抽象类和抽象方法

- 随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它**没有具体的实例**，这样的类叫做抽象类。

- 用abstract关键字来修饰一个类，这个类叫做**抽象类**。

-  用abstract来修饰一个方法，该方法叫做**抽象方法**。
  - 抽象方法：只有方法的声明，没有方法的实现。以分号结束：
  - 比如：public abstract void talk(）；
  
- **含有抽象方法的类必须被声明为抽象类。**

- 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。

- **不能用abstract修饰变量、代码块、构造器**；

- **不能用abstract修饰私有方法、静态方法、final的方法、final的类**。

- 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。

- ##### 多态的应用：模板方法设计模式

  - 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用**模板**，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。
  -  解决的问题：
    - 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
    - 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。
  - 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：
    - 数据库访问的封装
    - Junit单元测试
    - JavaWeb的Servlet中关于doGet/doPost方法调用
    - Hibernate中模板程序
    - Spring中JDBCTemlate、Hibernate Template等

### 24.接口

- 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。

- 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。

- 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要.…则必须能…”的思想。**继承是一个“是不是“的关系，而接口实现则是“能不能”的关系。**

-  **接口的本质是契约，标准，规范**，就像我们的法律一样。制定好后大家都要遵守。

- 接口（interface)是**抽象方法和常量值**定义的集合。

- 接口的特点：

  - 用interface来定义。
  - 接口中的所有成员变量都**默认**是由public static final修饰的。
  - 接口中的所有抽象方法都**默认**是由public abstract修饰的。
  - **接口中没有构造器。**
  - 接口采用多继承机制。

- 定义Java类的语法格式：**先写extends，后写implements**

  - class SubClass extends SuperClass implements InterfaceA{}

- 一个类可以实现多个接口，接口也可以继承其它接口。

- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。

- 接口的主要用途就是被实现类实现。（**面向接口编程**）

- 与继承关系类似，接口与实现类之间存在**多态性**

- 接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义（**JDK7.0及之前**），而没有变量和方法的实现。

- ##### 接口的应用：代理模式

  - 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。
  - 应用场景：
    - 安全代理：屏蔽对真实角色的直接访问。
    - 远程代理：通过代理类处理远程方法调用（RMl）
    - 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。
  - 分类
    - 静态代理（静态定义代理类）
    - 动态代理（动态生成代理类）
      - JDK自带的动态代理，需要反射等知识

- ##### 接口的应用：工厂模式

  - 工厂模式：**实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。**

  - 其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护，解决方式就是一个“分工”。

  - ##### 面向对象的设计原则

    - ###### OCP（开闭原则，Open-Closed Principle)

      - **一个软件的实体应当对扩展开放，对修改关闭。**
      - 当我们写完的代码，不能因为需求变化就修改。我们可以通过**新增代码的方式来解决变化的需求**。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。说到底，开闭原则除了表面上的可扩展性强以外，在企业中更看重的是维护成本。
      - 所以，开闭原则是设计模式的第一大原则，它的潜台词是：**控制需求变动风险，缩小维护成本。**

    - ######  DIP（依赖倒转原则，Dependence Inversion Principle)

      - 要针对接口编程，不要针对实现编程。
      - **如果A中关联B，那么尽量使得B实现某个接口，然后A与接口发生关系，不与B实现类发生关联关系。**
      - 依赖倒置的潜台词是：**面向抽象编程，解耦调用和被调用者。**

    - ######   LOD（迪米特法则，Law Of Demeter)

      - 只与你直接的朋友通信，而避免和陌生人通信。
      -  要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。这是封装特性的典型体现。
      - 一个类如果暴露太多私用的方法和字段，会让调用者很茫然。并且会给类造成不必要的判断代码。所以，我们使用尽量低的访问修饰符，让外界不知道我们的内部。这也是面向对象的基本思路。这是迪米特原则的一个特性，**无法了解类更多的私有信息**。
      - 另外，迪米特原则要求类之间的直接联系尽量的少，两个类的访问，**通过第三个中介类来实现**。
      - 迪米特原则的潜台词是：**不和陌生人说话，有事去中介**。

  - ##### 工厂模式的分类：

    - 简单工厂模式：用来生产同一等级结构中的任意产品。（**对于增加新的产品，需要修改已有代码**）
    - 工厂方法模式：用来生产同一等级结构中的固定产品。（**支持增加任意产品**）
    - 抽象工厂模式：用来生产不同产品族的全部产品。（**对于增加新的产品，无能为力；支持增加产品族**）

  - ##### 核心本质：

    - 实例化对象，用工厂方法代替new操作。
    - 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

  - ##### 代码：

    - ##### 1.无工厂模式

      ```java
      interface Car{
          void run();
      }
      class Audi implements Car{
          public void run(){
              System.out.println("奥迪在跑");
          }
      }
      class BYD implements Car{
          public void run(){
              System.out.println("比亚迪在跑");
          }
      }
      public class Client01{
          public static void main(String[] args){
              Car a = new Audi();
              Car b = new BYD();
              a.run();
              b.run();
          }
      }
      ```

    - ##### 2.简单工厂模式：定义一个用于创建对象的工厂类

      ```java
      interface Car{
          void run();
      }
      class Audi implements Car{
          public void run(){
              System.out.println("奥迪在跑");
          }
      }
      class BYD implements Car{
          public void run(){
              System.out.println("比亚迪在跑");
          }
      }
      //工厂类
      class CarFactory{
          //方式一
          public static Car getCar(String type){
              if("奥迪".equals(type)){
                  return new Audi();
              }else if("比亚迪".equals(type)){
                  return new BYD();
              }else{
                  return null;
              }
          }
          
          //方式二
          public static Car getAudi(){
              return new Audi();
          }
          public static Car getByd(){
              return new BYD();
          }
      }
      public class Client02{
          public static void main(String[] args){
              Car a = CarFactory.getCar("奥迪");
              a.run();
              Car b = CarFactory.getCar("比亚迪");
              b.run();
          }
      }
      ```

      -  调用者只要知道他要什么，从哪里拿，如何创建，不需要知道。分工，多出了一个专门生产Car的实现类对象的工厂类。**把调用者与创建者分离**。
      - 小结：
        - 简单工厂模式也叫**静态工厂模式**，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的实例对象。
        - 缺点：**对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则（对扩展开放；对修改封闭）。**

    - ##### 3.工厂方法模式

      - 为了避免简单工厂模式的缺点，**不完全满足OCP**（对扩展开放，对修改关闭）。

      - 工厂方法模式和简单工厂模式最大的不同在于，**简单工厂模式只有一个（对于一个项目或者一个独立的模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类**。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。

        ```java
        interface Car{
            void run();
        }
        class Audi implements Car{
            public void run(){
                System.out.println("奥迪在跑");
            }
        }
        class BYD implements Car{
            public void run(){
                System.out.println("比亚迪在跑");
            }
        }
        //工厂接口
        interface Factory{
            Car getCar();
        }
        //两个工厂类
        class AudiFactory implements Factory{
            public Audi getCar(){
                return new Audi();
            }
        }
        class BydFactory implements Factory{
            public BYD getCar(){
                return new BYD();
            }
        }
        public class Client{
            public static void main(String[] args){
                Car a = new AudiFactory().getCar();
                Car b = new BydFactory().getCar();
                a.run();
                b.run();
            }
        }
        ```

      -  总结：简单工厂模式与工厂方法模式真正的避免了代码的改动了？

      - **没有**。在简单工厂模式中，新产品的加入要修改工厂角色中的判断语句；

      - 而在工厂方法模式中，要么将判断逻辑留在抽象工厂角色中，要么在客户程序中将具体工厂角色写死（就像上面的例子一样）。而且产品对象创建条件的改变必然会引起工厂角色的修改。

      - 面对这种情况，**Java的反射机制与配置文件的巧妙结合突破了限制——这在Spring 中完美的体现了出来。**

    - ##### 4.抽象工厂模式

      -  **抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上。**而且抽象工厂模式是三个里面最为抽象、最具一般性的。
      - 抽象工厂模式的用意为：**给客户端提供一个接口，可以创建多个产品族中的产品对象。**
      - 而且使用抽象工厂模式还要满足一下条件：
        - 1)系统中有多个产品族，而系统一次只可能消费其中一族产品。
        - 2）同属于同一个产品族的产品以其使用。

  - 接口和抽象类之间的对比

    |  NO  |    区别点    |                            抽象类                            |                     接口                      |
    | :--: | :----------: | :----------------------------------------------------------: | :-------------------------------------------: |
    |  1   |     定义     |                       包含抽象方法的类                       |        主要是抽象方法和全局常量的集合         |
    |  2   |     组成     |           构造方法，抽象方法，普通方法，常量，变量           | 常量，抽象方法，（jdk8.0:默认方法，静态方法） |
    |  3   |     使用     |                  子类继承抽象类（extends）                   |           子类实现接口(implements)            |
    |  4   |     关系     |                    抽象类可以实现多个接口                    |    接口不能继承抽象类，但允许继承多个接口     |
    |  5   | 常见设计模式 |                           模板方法                           |         简单工厂，工厂方法，代理模式          |
    |  6   |     对象     |               都通过对象的多态性产生实例化对象               |       都通过对象的多态性产生实例化对象        |
    |  7   |     局限     |                     抽象类有单继承的局限                     |                 接口没有局限                  |
    |  8   |     实际     |                         作为一个模板                         |         是作为一个标准或表示一种能力          |
    |  9   |     选择     | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                               |

- ##### java8中关于接口的改进

  -  Java8中，你可以为接口添加**静态方法和默认方法**。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。
  -  静态方法：使用static关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。
  -  默认方法：默认方法使用**default** 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。
  - 比如：java 8APl中对Collection、List、Comparator等接口提供了丰富的默认方法。

- ##### 接口中的默认方法

  - 若一个接口中定义了**一个默认方法**，而另外一个接口中也定义了**一个同名同参数的方法**（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：**接口冲突**。
    - 解决办法：**实现类必须覆盖接口中同名同参数的方法，来解决冲突**。
  - 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：**类优先原则**。接口中具有相同名称和参数的默认方法会被忽略。

### 25.内部类

- 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用**内部类**。

- - **Inner class的名字不能与包含它的外部类类名相同**；

- 分类：

  - 成员内部类（static成员内部类和非static成员内部类）
  - 局部内部类（不谈修饰符）、匿名内部类

- ##### 成员内部类作为类的成员的角色：

  - 和外部类不同，Inner class还可以声明为private或protected；
  - 可以调用外部类的结构
  - Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；

- ##### 成员内部类作为类的角色：

  - 可以在内部定义属性、方法、构造器等结构
  - 可以声明为abstract类，因此可以被**其它的内部类继承**
  - 可以声明为final的
  - 编译以后生成OuterClass$lnnerClass.class字节码文件（也适用于局部内部类）

- ##### 【注意】

  - 1.**非static的成员内部类中的成员不能声明为static的**，只有在外部类或static的成员内部类中才可声明static成员
  - 2.外部类访问成员内部类的成员，需要“**内部类.成员”或“内部类对象.成员”**的方式
  - 3.成员内部类可以直接使用外部类的所有成员，包**括私有的数据**
  - 4.当想要在外部类的静态成员部分使用内部类时，可以考虑内部类**声明为静态**的的技术

- ##### 如何声明局部内部类

  - class外部类{

    - 方法（）{
      - class局部内部类{
      - }
    - }
    - {
      - class局部内部类{
        - }
      - }
    - }

  - ##### 如何使用局部内部类

    - 只能在**声明它的方法或代码块中使用，而且是先声明后使用**。除此之外的任何地方都不能使用该类
    - 但是它的对象可以**通过外部方法的返回值返回使用**，返回值类型只能是局部内部类的父类或父接口类型

  - #####  局部内部类的特点

    - 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。
    - 只能在**声明它的方法或代码块中使用**，而且是先声明后使用。除此之外的任何地方都不能使用该类。
    - 局部内部类可以使用外部类的成员，包括私有的。
    - 局部内部类**可以使用外部方法的局部变量**，但是**必须是final**的。由局部内部类和局部变量的声明周期不同所致。
    - 局部内部类和局部变量地位类似，**不能使用public,protected,缺省，private**
    - **局部内部类不能使用static修饰，因此也不能包含静态成员**

  - ##### 匿名内部类

    -  匿名内部类不能定义任何静态成员、方法和类，只能**创建匿名内部类的一个实例**。一个匿名内部类一定是在**new的后面**，用其隐含实现一个接口或实现一个类。

    - 格式：

      - new父类构造器（实参列表）|实现接口(）{
        - //匿名内部类的类体部分
        - }

    - ##### 匿名内部类的特点

      - 匿名内部类必须继承父类或实现接口
      - 匿名内部类只能有一个对象
      - 匿名内部类对象只能使用**多态形式**引用

### **26.面试题**

- ##### 问：在程序中是否可以通知垃圾回收机制过来回收垃圾？
  
  - 能，通过调用System.gc();或Runtime.getRuntime().gc();
  
- ##### 再问：调用了System.gc();或Runtime.getRuntime().gc();后是立刻执行垃圾回收吗？
  
  - 不是，该调用并不会立刻启动垃圾回收机制开始回收，但会加快垃圾回收机制的运行。
  
- ##### 多态是编译时行为还是运行时行为？如何证明？

  - 证明见：

    ```java
    import java.util.Random;
    
    //面试题：多态是编译时行为还是运行时行为？
    //证明如下：
    class Animal  {
    	protected void eat() {
    		System.out.println("animal eat food");
    	}
    }
    
    class Cat  extends Animal  {
    	protected void eat() {
    		System.out.println("cat eat fish");
    	}
    }
    
    class Dog  extends Animal  {
    	public void eat() {
    		System.out.println("Dog eat bone");
    	}
    }
    
    class Sheep  extends Animal  {
    	public void eat() {
    		System.out.println("Sheep eat grass");
    	}
    }
    
    public class InterviewTest {
    	public static Animal  getInstance(int key) {
    		switch (key) {
    		case 0:
    			return new Cat ();
    		case 1:
    			return new Dog ();
    		default:
    			return new Sheep ();
    		}
    	}
    	public static void main(String[] args) {
    		int key = new Random().nextInt(3);
    		System.out.println(key);
    		Animal animal = getInstance(key);
    		animal.eat(); 
    	}
    }
    ```

  - 拓展问题：

    ```java
    //考查多态的笔试题目：
    public class InterviewTest1 {
    	public static void main(String[] args) {
    		Base base = new Sub();
    		base.add(1, 2, 3);
    //		Sub s = (Sub)base;
    //		s.add(1,2,3);
    	}
    }
    
    class Base {
    	public void add(int a, int... arr) {
    		System.out.println("base");
    	}
    }
    
    class Sub extends Base {
    	public void add(int a, int[] arr) {
    		System.out.println("sub_1");
    	}
    //	public void add(int a, int b, int c) {
    //		System.out.println("sub_2");
    //	}
    }
    //决定输出的内容，是由接受的类型决定的
    ```

- ##### ==和equals的区别

  -  ==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址
  - equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==；我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。
  - 具体要看自定义类里有没有重写Object的equals方法来判断。
  - 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。

- ##### 写出输出结果：

  ```java
  public void test(){ 
      char[]arr=new char[]{'a','b','c'}; 
      System.out.println(arr);// abc
      int[]arr1=new int[]{1,2,3}; 
      System.out.println(arr1);// 内存地址
      double[]arr2=new double[]{1.1,2.2,3.3}; 
      System.out.println(arr2);//内存地址
  }
  ```

- ##### 如下两个题目的输出结果相同吗？各是什么：

  ```java
  Object ol =true ? new Integer(1):new Double(2.0); 
  System.out.println(ol);//1.0
  
  Object o2; 
  if(true) 
      o2=new Integer(1); 
  else 
      o2=new Double(2.0);
  System.out.println(o2);//1
  ```

- ##### 写出下面的输出结果：

  ```java
  public void method1(){ 
      Integer i=new Integer(1); 
      Integer j=new Integer(1); 
      System.out.println(i==j); //false
      Integer m=1; Integer n=1; 
      System.out.println(m==n);// true
      Integer x=128; 
      Integer y=128; 
      System.out.println(x==y);//false
  }
  ```

- ##### 此处，Something类的文件名叫OtherThing.java

  ```java
  class Something{ 
      public static void main(String[] something_to_do){ 
          System.out.printin("Do something …");
      } 
  }
  //上述程序是否可以正常编译、运行？
  //能
  ```

- ##### 排错

  ```java
  public class Something{
      //常量不可以修改
      public int addOne(final int x){
          return ++x;
      }
      public static void main(String[] args){
          Other o = new Other();
          new Something().addOne(o);
      }
      public void addOne(final Other o){
          o.i++;
      }
  }
  class Other{
      public int i;
  }
  ```

  ```java
  interface A{ 
      int x = 0;
  } 
  class B{ 
      int x = 1;
  } 
  class C extends B implements A{ 
      public void px(){ 
          //匹配到了两个变量
          System.out.println(x);
      } 
      public static void main(String[] args){ 
          new C().pX();
      }
  }
  ```
  
  ```java
  interface Playable{ 
      void play();
  } 
  interface Bounceable{ 
      void play();
  } 
  interface Rollable extends Playable, Bounceable{ 
      Ball ball=new Ball("Pingpang");
  }
  class Ball implements Rollable{ 
      private String name; 
      public String getName(){ 
          return name;
      } 
      public Ball(String name){ 
          this.name=name;
      }
      public void play(){ 
          //接口中的变量都是final的
          ball = new Ball("Football");
          System.out.println(ball.getName());
      }
  }
  ```

## 第五章：异常处理

### 1.异常概述与异常体系结构

- 异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常）
- Java程序在执行过程中所发生的异常事件可分为两类：
  - Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。
  - Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：
    - 空指针访问
    - 试图读取不存在的文件
    - 网络连接中断
    - 数组角标越界
- 对于这些错误，一般有两种解决方法：
  - 一是遇到错误就终止程序的运行。
  - 另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。
- 捕获错误最理想的是在**编译期间**，但有的错误只有在**运行时**才会发生。
  - 比如：除数为0，数组下标越界等
- 分类：**编译时异常和运行时异常**
  -  1.运行时异常
    - 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。
    - 对于这类异常，**可以不作处理**，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。
  -  2.编译时异常
    - 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。**编译器要求Java程序必须捕获或声明所有编译时异常。**
    - 对于这类异常，如果程序不处理，可能会带来意想不到的结果。

### 2.常见的异常

-  java.lang.RuntimeException 
  - ClassCastException 
  - ArrayIndexOutOfBoundsException 
  - NullPointerException 
  - ArithmeticException 
  - NumberFormatException 
  - InputMismatchException 
  - 。。。
- java.io.IOExeption 
  - FileNotFoundException 
  - EOFException 
- java.lang.ClassNotFoundException 
- java.lang.InterruptedException 
- java.io.FileNotFoundException 
- java.sql.SQLException

### 3.try-catch-finally

-  在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，**要检测分母为0，数据为空，输入的不是数据而是字符**等。过多的if-else分支会导致程序的代码加长、腌肿，可读性差。因此采用异常处理机制。

- **Java异常处理**

  - Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。

- Java异常处理的方式：

  - 方式一：try-catch-finally
  - 方式二：throws + 异常类型

-  Java提供的是异常处理的**抓抛模型**。

- Java程序的执行过程中如出现异常，会生成一个**异常类对象**，该异常对象将被提交给Java运行时系统，这个过程称为**抛出（throw)异常。**

- 异常对象的生成

  - 由虚拟机**自动生成**：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出
  - 由开发人员**手动创建**：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样

-  如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。 这一过程称为捕获（catch）异常。

- 如果一个异常回到main（）方法，并且main（）也不处理，则程序运行终止。

- 程序员通常只能处理Exception，而对Error无能为力。

- 异常处理是通过try-catch-finally语句实现的。

  -  try{
    - ...//可能产生异常的代码
    - }
    - catch(ExceptionName1 e){
      - ...//当产生ExceptionName1型异常时的处置措施
    - }
    - catch(ExceptionName2 e){
      - ...//当产生ExceptionName2型异常时的处置措施
    - }
    - [finally{
      - ...//无论是否发生异常，都无条件执行的语句
    - }]

- try

  - 捕获异常的第一步是用try{..}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。

- catch(Exceptiontype e)

  - 在catch语句块中是对**异常对象**进行处理的代码。每个try语句块可以伴随一个或**多个**catch语句，用于处理可能产生的**不同类型**的异常对象。

- 如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。

  - 比如：可以用ArithmeticException类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。
  - 但不能是与ArithmeticException类**无关的异常**，如NulPointerException（catch中的语句将不会执行）

- ##### 捕获异常的有关信息：

  - 与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。
    - getMessage（)获取异常信息，返回字符串
    - printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。

- #####  finally

  - 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。
  - **不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。**
  - finally语句和catch语句是任选的

- ##### 不捕获异常的情况、

  - 前面使用的异常都是**RuntimeException**类或是它的子类，这些类的异常的特点是：**即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过（但运行时会发生异常使得程序运行终止）。**
  -  如果抛出的异常是IOException等类型的非运行时异常，则**必须捕获，否则编译错误**。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常

### 4.throws

- 声明抛出异常是Java中处理异常的第二种方式
  - 如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应**显示地**声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的**调用者**负责处理。
  - 在方法声明中用**throws**语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。
- 声明抛出异常举例：
  - public void readFile(String file)throws FileNotFoundException{
    - //读文件的操作可能产生FileNotFoundException类型的异常
    - FilelnputStream fis=new FilelnputStream(file);
  - }
- 重写方法**不能抛出比被重写方法范围更大的异常类型**。在多态的情况下，对methodA（）方法的调用-异常的捕获按父类声明的异常处理。

### 5.手动抛出异常

- Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。
  - 首先要生成异常类对象，然后通过throw语句实现抛出操作（提交给Java运行环境）。
    - IOException e=new IOException()；
    - throw e；
  - 可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：
    - throw new String("want to throw")；

### 6.用户自定义异常类

-  一般地，用户自定义异常类都是**RuntimeException**的子类。

- 自定义异常类通常需要编写几个**重载的构造器**。

- 自定义异常需要提供**serialVersionUID**

- 自定义的异常通过**throw抛出**。

- 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。

- 用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。

- ##### 异常处理5个关键字

  - 捕获异常：
    - try 执行可能产生异常的代码
    - catch 捕获异常
    - finally 无论是否发生异常，代码总被执行
  - 抛出异常
    - throw 异常的生成阶段 手动抛出异常对象
  - 声明异常
    - throws 异常处理方式：声明方法可能要抛出的各种异常类